
/**
 * 【初始化】(指第一次赋值)一般紧跟【分配空间】，在cpp中可以认为是【对象的构造】
 * 【生命周期】指的是对象构造时至析构时
 * 【作用域】为对象可见范围，能通过命名找到对应值的范围
 * 
 * 程序的产出和运行的完整过程可分为【编译时】、【加载时】和【运行时】
 * 全局变量初始化时间分为编译时和加载时，静态变量多了一个运行时，对于局部静态变量
 * 
 * 1. 全局变量
 *   生命周期：编译或加载时到程序结束
 *   作用域：所有源文件
 *   存储区：data段（初始化的，编译时），bss(默认初始化的，加载时)
 * 
 * 2. 全局静态变量
 *   生命周期：编译或加载时到程序结束
 *   作用域： 当前文件
 *   存储区：data段（初始化的，编译时），bss(默认初始化的，加载时)
 * 
 * 3. 局部变量
 *   生命周期：函数或{}内
 *   作用域：{}内
 *   存储区：栈
 * 
 * 4. 局部静态变量
 *   生命周期：第一次被访问到程序结束
 *   作用域：{}内
 *   存储区：data段（初始化的），bss(默认初始化的)
 * 
 * 5. 动态变量（malloc/free, new/delete）
 *   生命周期：手动申请至手动释放时
 *   作用域：看申请的位置
 *   存储区：堆（申请很大的空间可能在文件映射区）
 * 
 * 6. const（表示只读，不改变生命周期、作用域和存储位置，必须在声明时初始化）
 * 7. constexpr（表示常量，表达式编译时求值，常用于在类的声明中初始化静态成员变量，必须在声明时初始化）
 */

#include <iostream>
#include <cstring>
#include <string>
using namespace std;


class A {
    const int val;
    constexpr A(): val(0) {}
};

/*
    const/constexpr 修饰的名一定要初始化：
        const可以修饰成员变量，但一定要在初始化列表初始化
        constexpr可以修饰构造函数，但得在初始化列表初始化成员，构造函数内不能有成员的赋值
*/


// 函数和类可近似看成全局变量，存储在代码段

int g = 1; // 全局变量
// int g; // 未初始化全局变量
const int cg = 1; // 全局只读变量，全局可见，外部可访问(但声明和定义处都要extern const)
// const int cgg; // error: 必须初始化

static int si = 1; // 静态全局变量，外部不可访问，生命周期为程序执行时，编译时初始化
// static int sii; // ok, bss，静态变量这里是加载时初始化（初始化为0）

static constexpr int cei = 1; // 编译时初始化，加了static则外部不可访问（局部变量还改变存储区）
// constexpr int ceii; // error: 常量必须在声明时初始化，常量与只读变量的区别是在编译时初始化

const int n = 5; // 不加const下一行报错
int b[n]; // cpp支持这么定义全局数组，但c只接受常量(这里是只读变量)

int main () {
    /*
        局部变量从存储上分，分为auto,static,register
        1) auto: 普通,存储在栈上或堆上,c++17后只用于自动推断变量类型
        2) static: 静态,存储在数据段
        3) register: 寄存器变量,存储在寄存器上(优先，但还要取决于硬件和实现的限制)
    */


    /* 简单类型 */

    int l = 0; // 局部变量，{}内可见，存储在栈
    int* l1 = new int(1); // l1指针局部变量，与普通局部变量一样，但指向的区域放在堆
    const int cl = 0; // 局部只读变量，{}内可见，存储在栈
    static int sl = 0; // 静态局部变量，{}内可见，存储在数据段
    constexpr int cel = 0+1; // 可用常量表达式声明,用变量声明会报错,eg., x+1，必须初始化


    /* const 修饰数组 */

    const int a[5]{1,2}; // {1,2,0,0,0} 
    // a[0] = 7; // error,不可直接修改
    
    // const修饰只读变量，可间接修改：
    int* p = (int*)&a;   // c++对类型检查更严格，&a指的是int(*)[5],c这里可以int*p = &a;
    *p = 7;
    cout << *p << endl; // 7
    cout << a[0]; // 7


    /* const 修饰指针 (关键：看const修饰的是什么) */

    int num = 5;
    const int* p1 = &num; // 指针可变，指向的东西不可变
    // error: *p1 = 6; ok: p1++;
    int* const p2 = &num; // 指针不可变，指向的东西可变
    // error: p2++; ok: *p2 = 6;
    const int* const p3 = &num; // 都不可变

    return 0;
}

