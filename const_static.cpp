
/**
 * 程序的产出和运行的完整过程可分为【编译时】、【加载时】和【运行时】
 * 编译链接，最终ELF可执行程序，除了头部和不需加载到用户空间的符号表和调试信息，
 * 
 * 把代码和常量写到【只读段】，
 * 把已确定值的【全局变量】【静态变量】写到【data段】，
 * 没确定值的【全局变量】【静态变量】写到【bss段】（只占位），
 * 将只读段和读写段加载到内存即在【分配空间】，在cpp中此时发生【对象的构造】
 * 
 * 【生命周期】指的是对象构造时至析构时
 * 【作用域】为对象可见范围，能通过命名找到对应值的范围
 * 全局变量初始化时间为加载时，静态变量多了一个运行时，对于局部静态变量
 * 
 * 1. 全局变量
 *   生命周期：加载时到程序结束
 *   作用域：所有源文件
 *   存储区：data段（初始化的），bss(默认初始化的)
 * 
 * 2. 全局静态变量
 *   生命周期：加载时到程序结束
 *   作用域： 当前文件
 *   存储区：data段（初始化的），bss(默认初始化的)
 * 
 * 3. 局部变量
 *   生命周期：函数或{}内
 *   作用域：{}内
 *   存储区：栈
 * 
 * 4. 局部静态变量
 *   生命周期：第一次被访问到程序结束
 *   作用域：{}内
 *   存储区：data段（初始化的），bss(默认初始化的)
 * 
 * 5. 动态变量（malloc/free, new/delete）
 *   生命周期：手动申请至手动释放时
 *   作用域：看申请的位置
 *   存储区：堆（申请很大的空间可能在文件映射区）
 * 
 * 6. const
 *    表示只读，不改变生命周期、作用域和存储位置，必须在声明时确定值
 * 
 * 7. constexpr：
 *    用于编译时计算表达式值，有助于提高性能，常用于
 *    在类的声明内部初始化静态成员变量，用于变量必须在声明时确定值
 *    在编译时确定数组大小或模板参数
 * 
 * 8. 函数和类可近似看成全局变量，存储在代码段
 */

#include <iostream>
#include <cstring>
#include <string>
using namespace std;


class A {
    // const可以修饰成员变量，但一定要在初始化列表初始化
    const int val;
    // constexpr还可以修饰构造函数，但得在初始化列表初始化成员，构造函数内不能有成员的赋值
    constexpr A(): val(0) {}
};



int g = 1; // 全局变量
// int g; // 未初始化全局变量
const int cg = 1; // 全局只读变量，外部可访问(但声明和定义处都要extern const)
// const int cgg; // error: 必须初始化

static int si = 1; // 静态全局变量，外部不可访问，生命周期为程序执行时
// static int sii; // ok, bss，这里是静态初始化

static constexpr int cei = 1; // 编译时确定值，加了static则外部不可访问
// constexpr int ceii; // error: 常量必须在声明时初始化，常量与只读变量的区别是在编译时确定值

const int n = 5; // 不加const下一行报错
int b[n]; // cpp支持这么定义全局数组，但c只接受常量(这里是只读变量)

int main () {
    /*
        局部变量从存储上分，分为auto,static,register
        1) auto: 普通,存储在栈上或堆上,c++17后只用于自动推断变量类型
        2) static: 静态,存储在数据段
        3) register: 寄存器变量,存储在寄存器上(优先，但还要取决于硬件和实现的限制)
    */


    /* 简单类型 */

    int l = 0; // 局部变量，{}内可见，存储在栈
    int* l1 = new int(1); // l1指针局部变量，与普通局部变量一样，但指向的区域放在堆
    const int cl = 0; // 局部只读变量，{}内可见，存储在栈
    static int sl = 0; // 静态局部变量，{}内可见，存储在数据段
    constexpr int cel = 0+1; // 可用常量表达式声明,用变量声明会报错,eg., x+1，必须初始化
    static constexpr int scel = 2; // 编译时确定值，且生命周期和存储区都改变


    /* const 修饰数组 */

    const int a[5]{1,2}; // {1,2,0,0,0} 
    // a[0] = 7; // error,不可直接修改
    
    // const修饰只读变量，可间接修改：
    int* p = (int*)&a;   // c++对类型检查更严格，&a指的是int(*)[5],c这里可以int*p = &a;
    *p = 7;
    cout << a[0]; // 7


    /* const 修饰指针 (关键：看const修饰的是什么) */

    int num = 5;
    const int* p1 = &num; // 指针可变，指向的东西不可变
    // error: *p1 = 6; ok: p1++;
    int* const p2 = &num; // 指针不可变，指向的东西可变
    // error: p2++; ok: *p2 = 6;
    const int* const p3 = &num; // 都不可变

    return 0;
}

